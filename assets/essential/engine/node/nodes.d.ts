declare module cc {
    interface Node {
        /* -------------------------------NodeS扩展------------------------------- */
        // __nodes_cache_a: any;
        // __nodes_a: {
        // 	/**初始化状态 */
        // 	init_b: boolean;
        // 	/**组件 */
        // 	component_map: Map<string, any>;
        // 	/**子节点 */
        // 	child_map: Map<string, cc.Node>;
        // 	/**自动更新子节点状态 */
        // 	child_update_b: boolean;
        // };
        /* ***************扩展子节点获取*************** */
        /**子节点获取 */
        child(v_s_: string, update_b_?: boolean): cc.Node;
        /**子节点自动更新 */
        child_update_b: boolean;
        /* ***************扩展组件获取*************** */
        component<T>(type: {prototype: T}, update_b_?: boolean): T;
        /**DragonBones 骨骼动画 (Armature Display 具有对骨骼数据的引用并且存储了骨骼实例的状态， 它由当前的骨骼动作，slot 颜色，和可见的 slot attachments 组成。 多个 Armature Display 可以使用相同的骨骼数据，其中包括所有的动画，皮肤和 attachments。) */
        dragon_bones: dragonBones.ArmatureDisplay;
        /**图形 */
        graphics: cc.Graphics;
        /**!#en The Label Component. !#zh 文字标签组件 */
        label: cc.Label;
        /**!#en Outline effect used to change the display, only for system fonts or TTF fonts !#zh 描边效果组件,用于字体描边,只能用于系统字体 */
        label_outline: cc.LabelOutline;
        /**!#en Shadow effect for Label component, only for system fonts or TTF fonts !#zh 用于给 Label 组件添加阴影效果，只能用于系统字体或 ttf 字体 */
        label_shadow: cc.LabelShadow;
        /**!#en The Light Component!#zh 光源组件 */
        light: cc.Light;
        /**!#en The Mask Component !#zh 遮罩组件 */
        mask: cc.Mask;
        /** Particle System base class. <br/>
        Attributes of a Particle System:<br/>
        - emmision rate of the particles<br/>
        - Gravity Mode (Mode A): <br/>
        - gravity <br/>
        - direction <br/>
        - speed +-  variance <br/>
        - tangential acceleration +- variance<br/>
        - radial acceleration +- variance<br/>
        - Radius Mode (Mode B):      <br/>
        - startRadius +- variance    <br/>
        - endRadius +- variance      <br/>
        - rotate +- variance         <br/>
        - Properties common to all modes: <br/>
        - life +- life variance      <br/>
        - start spin +- variance     <br/>
        - end spin +- variance       <br/>
        - start size +- variance     <br/>
        - end size +- variance       <br/>
        - start color +- variance    <br/>
        - end color +- variance      <br/>
        - life +- variance           <br/>
        - blending function          <br/>
        - texture                    <br/>
        <br/>
        cocos2d also supports particles generated by Particle Designer (http://particledesigner.71squared.com/).<br/>
        'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guarateed in cocos2d,  <br/>
        cocos2d uses a another approach, but the results are almost identical.<br/>
        cocos2d supports all the variables used by Particle Designer plus a bit more:  <br/>
        - spinning particles (supported when using ParticleSystem)       <br/>
        - tangential acceleration (Gravity mode)                               <br/>
        - radial acceleration (Gravity mode)                                   <br/>
        - radius direction (Radius mode) (Particle Designer supports outwards to inwards direction only) <br/>
        It is possible to customize any of the above mentioned properties in runtime. Example:   <br/> */
        particle_system: cc.ParticleSystem;
        /**!#en The ParticleSystem3D Component. !#zh 3D 粒子组件 */
        particle_system_3d: cc.ParticleSystem3D;
        /**!#en The RichText Component. !#zh 富文本组件 */
        rich_text: cc.RichText;
        /**!#en The skeleton of Spine (Skeleton has a reference to a SkeletonData and stores the state for skeleton instance, which consists of the current pose's bone SRT, slot colors, and which slot attachments are visible. Multiple skeletons can use the same SkeletonData which includes all animations, skins, and attachments.) !#zh Spine 骨骼动画 (Skeleton 具有对骨骼数据的引用并且存储了骨骼实例的状态， 它由当前的骨骼动作，slot 颜色，和可见的 slot attachments 组成。 多个 Skeleton 可以使用相同的骨骼数据，其中包括所有的动画，皮肤和 attachments。 */
        sp_skeleton: sp.Skeleton;
        /**!#en Renders a sprite in the scene. !#zh 该组件用于在场景中渲染精灵 */
        sprite: cc.Sprite;
        /**!#en Renders a TMX Tile Map in the scene. !#zh 在场景中渲染一个 tmx 格式的 Tile Map。 */
        tiled_map: cc.TiledMap;
        /**!#en TiledTile can control the specified map tile. It will apply the node rotation, scale, translate to the map tile. You can change the TiledTile's gid to change the map tile's style. !#zh TiledTile 可以单独对某一个地图块进行操作。 他会将节点的旋转，缩放，平移操作应用在这个地图块上，并可以通过更换当前地图块的 gid 来更换地图块的显示样式。 */
        tiled_tile: cc.TiledTile;
        /**!#en Mesh Renderer Component !#zh 网格渲染组件 */
        mesh_renderer: cc.MeshRenderer;
        /**!#en Skinned Mesh Renderer !#zh 蒙皮渲染组件 */
        skinned_mesh_renderer: cc.SkinnedMeshRenderer;
        /**!#en This component will block all input events (mouse and touch) within the bounding box of the node, preventing the input from penetrating into the underlying node, typically for the background of the top UI. This component does not have any API interface and can be added directly to the scene to take effect. !#zh 该组件将拦截所属节点 bounding box 内的所有输入事件（鼠标和触摸），防止输入穿透到下层节点，一般用于上层 UI 的背景。 该组件没有任何 API 接口，直接添加到场景即可生效 */
        block_input_events: cc.BlockInputEvents;
        /** !#en
        Button has 4 Transition types<br/>
        When Button state changed:<br/>
        If Transition type is Button.Transition.NONE, Button will do nothing<br/>
        If Transition type is Button.Transition.COLOR, Button will change target's color<br/>
        If Transition type is Button.Transition.SPRITE, Button will change target Sprite's sprite<br/>
        If Transition type is Button.Transition.SCALE, Button will change target node's scale<br/>

        Button will trigger 5 events:<br/>
        Button.EVENT_TOUCH_DOWN<br/>
        Button.EVENT_TOUCH_UP<br/>
        Button.EVENT_HOVER_IN<br/>
        Button.EVENT_HOVER_MOVE<br/>
        Button.EVENT_HOVER_OUT<br/>
        User can get the current clicked node with 'event.target' from event object which is passed as parameter in the callback function of click event.

        !#zh
        按钮组件。可以被按下，或者点击。

        按钮可以通过修改 Transition 来设置按钮状态过渡的方式：

        - Button.Transition.NONE   // 不做任何过渡
        - Button.Transition.COLOR  // 进行颜色之间过渡
        - Button.Transition.SPRITE // 进行精灵之间过渡
        - Button.Transition.SCALE // 进行缩放过渡

        按钮可以绑定事件（但是必须要在按钮的 Node 上才能绑定事件）：<br/>
        以下事件可以在全平台上都触发：

        - cc.Node.EventType.TOUCH_START  // 按下时事件
        - cc.Node.EventType.TOUCH_Move   // 按住移动后事件
        - cc.Node.EventType.TOUCH_END    // 按下后松开后事件
        - cc.Node.EventType.TOUCH_CANCEL // 按下取消事件

        以下事件只在 PC 平台上触发：

        - cc.Node.EventType.MOUSE_DOWN  // 鼠标按下时事件
        - cc.Node.EventType.MOUSE_MOVE  // 鼠标按住移动后事件
        - cc.Node.EventType.MOUSE_ENTER // 鼠标进入目标事件
        - cc.Node.EventType.MOUSE_LEAVE // 鼠标离开目标事件
        - cc.Node.EventType.MOUSE_UP    // 鼠标松开事件
        - cc.Node.EventType.MOUSE_WHEEL // 鼠标滚轮事件

        用户可以通过获取 __点击事件__ 回调函数的参数 event 的 target 属性获取当前点击对象。 */
        button: cc.Button;
        /**!#zh: 作为 UI 根节点，为所有子节点提供视窗四边的位置信息以供对齐，另外提供屏幕适配策略接口，方便从编辑器设置。 注：由于本节点的尺寸会跟随屏幕拉伸，所以 anchorPoint 只支持 (0.5, 0.5)，否则适配不同屏幕时坐标会有偏差。 */
        canvas: cc.Canvas;
        /**!#en cc.EditBox is a component for inputing text, you can use it to gather small amounts of text from users. !#zh EditBox 组件，用于获取用户的输入文本。 */
        edit_box: cc.EditBox;
        /**!#en The Layout is a container component, use it to arrange child elements easily. Note： 1.Scaling and rotation of child nodes are not considered. 2.After setting the Layout, the results need to be updated until the next frame, unless you manually call {{#crossLink "Layout/updateLayout:method"}}{{/crossLink}}。 !#zh Layout 组件相当于一个容器，能自动对它的所有子节点进行统一排版。 注意： 1.不会考虑子节点的缩放和旋转。 2.对 Layout 设置后结果需要到下一帧才会更新，除非你设置完以后手动调用 {{#crossLink "Layout/updateLayout:method"}}{{/crossLink}}。 */
        layout: cc.Layout;
        /**!#en The PageView control !#zh 页面视图组件 */
        page_view: cc.PageView;
        /**!#en The Page View Indicator Component !#zh 页面视图每页标记组件 */
        page_view_indicator: cc.PageViewIndicator;
        /**!#en Visual indicator of progress in some operation. Displays a bar to the user representing how far the operation has progressed. !#zh 进度条组件，可用于显示加载资源时的进度。 */
        progress_bar: cc.ProgressBar;
        /**!#en The Scrollbar control allows the user to scroll an image or other view that is too large to see completely !#zh 滚动条组件 */
        scroll_bar: cc.Scrollbar;
        /**!#en Layout container for a view hierarchy that can be scrolled by the user, allowing it to be larger than the physical display.!#zh 滚动视图组件 */
        scroll_view: cc.ScrollView;
        /**!#en The Slider Control !#zh 滑动器组件 */
        slider: cc.Slider;
        /**!#en The toggle component is a CheckBox, when it used together with a ToggleGroup, it could be treated as a RadioButton. !#zh Toggle 是一个 CheckBox，当它和 ToggleGroup 一起使用的时候，可以变成 RadioButton */
        toggle: cc.Toggle;
        /**!#en ToggleContainer is not a visiable UI component but a way to modify the behavior of a set of Toggles. Toggles that belong to the same group could only have one of them to be switched on at a time. Note: All the first layer child node containing the toggle component will auto be added to the container !#zh ToggleContainer 不是一个可见的 UI 组件，它可以用来修改一组 Toggle 组件的行为。 当一组 Toggle 属于同一个 ToggleContainer 的时候，任何时候只能有一个 Toggle 处于选中状态。 注意：所有包含 Toggle 组件的一级子节点都会自动被添加到该容器中 */
        toggle_container: cc.ToggleContainer;
        /**!#en ToggleGroup is not a visiable UI component but a way to modify the behavior of a set of Toggles. Toggles that belong to the same group could only have one of them to be switched on at a time. !#zh ToggleGroup 不是一个可见的 UI 组件，它可以用来修改一组 Toggle 组件的行为。当一组 Toggle 属于同一个 ToggleGroup 的时候， 任何时候只能有一个 Toggle 处于选中状态。 */
        toggle_group: cc.ToggleGroup;
        /**!#en cc.VideoPlayer is a component for playing videos, you can use it for showing videos in your game. Because different platforms have different authorization, API and control methods for VideoPlayer component. And have not yet formed a unified standard, only Web, iOS, and Android platforms are currently supported. !#zh Video 组件，用于在游戏中播放视频。由于不同平台对于 VideoPlayer 组件的授权、API、控制方式都不同，还没有形成统一的标准，所以目前只支持 Web、iOS 和 Android 平台。 */
        video_player: cc.VideoPlayer;
        /**!#en cc.WebView is a component for display web pages in the game. Because different platforms have different authorization, API and control methods for WebView component. And have not yet formed a unified standard, only Web, iOS, and Android platforms are currently supported. !#zh WebView 组件，用于在游戏中显示网页。由于不同平台对于 WebView 组件的授权、API、控制方式都不同，还没有形成统一的标准，所以目前只支持 Web、iOS 和 Android 平台。 */
        web_view: cc.WebView;
        /**!#en Stores and manipulate the anchoring based on its parent. Widget are used for GUI but can also be used for other things. Widget will adjust current node's position and size automatically, but the results after adjustment can not be obtained until the next frame unless you call {{#crossLink "Widget/updateAlignment:method"}}{{/crossLink}} manually. !#zh Widget 组件，用于设置和适配其相对于父节点的边距，Widget 通常被用于 UI 界面，也可以用于其他地方。 Widget 会自动调整当前节点的坐标和宽高，不过目前调整后的结果要到下一帧才能在脚本里获取到，除非你先手动调用 {{#crossLink "Widget/updateAlignment:method"}}{{/crossLink}}。 */
        widget: cc.Widget;
        /**!#en Box Collider. !#zh 包围盒碰撞组件 */
        box_collider: cc.BoxCollider;
        /**!#en Circle Collider. !#zh 圆形碰撞组件 */
        circle_collider: cc.CircleCollider;
        /**!#en Polygon Collider. !#zh 多边形碰撞组件 */
        polygon_collider: cc.PolygonCollider;
        /**物理盒碰撞组件 */
        physics_box_collider: cc.PhysicsBoxCollider;
        /**!#en Physics box collider !#zh 物理盒子碰撞器 */
        box_collider_3d: cc.BoxCollider3D;
        /**物理链碰撞组件 */
        physics_chain_collider: cc.PhysicsChainCollider;
        /**物理圆碰撞组件 */
        physics_circle_collider: cc.PhysicsCircleCollider;
        /**物理多边形碰撞组件 */
        physics_polygon_collider: cc.PhysicsPolygonCollider;
        /**!#en Physics sphere collider !#zh 物理球碰撞器 */
        sphere_collider_3d: cc.SphereCollider3D;
        /**!#en Each frame applies a constant force to a rigid body, depending on the RigidBody3D !#zh 在每帧对一个刚体施加持续的力，依赖 RigidBody3D 组件 */
        constant_force: cc.ConstantForce;
        /**!#en A distance joint constrains two points on two bodies to remain at a fixed distance from each other. You can view this as a massless, rigid rod. !#zh 距离关节通过一个固定的长度来约束关节链接的两个刚体。你可以将它想象成一个无质量，坚固的木棍。 */
        distance_joint: cc.DistanceJoint;
        /**!#en A motor joint is used to control the relative motion between two bodies. A typical usage is to control the movement of a dynamic body with respect to the ground. !#zh 马达关节被用来控制两个刚体间的相对运动。 一个典型的例子是用来控制一个动态刚体相对于地面的运动。 */
        motor_joint: cc.MotorJoint;
        /**!#en A mouse joint is used to make a point on a body track a specified world point. This a soft constraint with a maximum force. This allows the constraint to stretch and without applying huge forces. Mouse Joint will auto register the touch event with the mouse region node, and move the choosed rigidbody in touch move event. Note : generally mouse joint only used in test bed. !#zh 鼠标关节用于使刚体上的一个点追踪一个指定的世界坐标系下的位置。 鼠标关节可以指定一个最大的里来施加一个柔和的约束。 鼠标关节会自动使用 mouse region 节点来注册鼠标事件，并且在触摸移动事件中移动选中的刚体。 注意：一般鼠标关节只在测试环境中使用。 */
        mouse_joint: cc.MouseJoint;
        /**!#en A prismatic joint. This joint provides one degree of freedom: translation along an axis fixed in rigidbody. Relative rotation is prevented. You can use a joint limit to restrict the range of motion and a joint motor to drive the motion or to model joint friction. !#zh 移动关节指定了只能在一个方向上移动刚体。 你可以开启关节限制来设置刚体运行移动的间距，也可以开启马达来使用关节马达驱动刚体的运行。 */
        prismatic_joint: cc.PrismaticJoint;
        /**!#en A revolute joint constrains two bodies to share a common point while they are free to rotate about the point. The relative rotation about the shared point is the joint angle. You can limit the relative rotation with a joint limit that specifies a lower and upper angle. You can use a motor to drive the relative rotation about the shared point. A maximum motor torque is provided so that infinite forces are not generated. !#zh 旋转关节可以约束两个刚体围绕一个点来进行旋转。 你可以通过开启关节限制来限制旋转的最大角度和最小角度。 你可以通过开启马达来施加一个扭矩力来驱动这两个刚体在这一点上的相对速度。 */
        revolute_joint: cc.RevoluteJoint;
        /**!#en A rope joint enforces a maximum distance between two points on two bodies. It has no other effect. Warning: if you attempt to change the maximum length during the simulation you will get some non-physical behavior. !#zh 绳子关节只指定两个刚体间的最大距离，没有其他的效果。 注意：如果你试图动态修改关节的长度，这有可能会得到一些意外的效果。 */
        rope_joint: cc.RopeJoint;
        /**!#en A weld joint essentially glues two bodies together. A weld joint may distort somewhat because the island constraint solver is approximate. !#zh 熔接关节相当于将两个刚体粘在了一起。 熔接关节可能会使某些东西失真，因为约束求解器算出的都是近似值。 */
        weld_joint: cc.WeldJoint;
        /**!#en A wheel joint. This joint provides two degrees of freedom: translation along an axis fixed in bodyA and rotation in the plane. You can use a joint motor to drive the rotation or to model rotational friction. This joint is designed for vehicle suspensions. !#zh 轮子关节提供两个维度的自由度：旋转和沿着指定方向上位置的移动。 你可以通过开启关节马达来使用马达驱动刚体的旋转。 轮组关节是专门为机动车类型设计的。 */
        wheel_joint: cc.WheelJoint;
        /**刚体 */
        rigid_body: cc.RigidBody;
        /**!#en Rigid body. !#zh 刚体组件。 */
        rigid_body_3d: cc.RigidBody3D;
        /** !#en The animation component is used to play back animations.

        Animation provide several events to register：
        - play : Emit when begin playing animation
        - stop : Emit when stop playing animation
        - pause : Emit when pause animation
        - resume : Emit when resume animation
        - lastframe : If animation repeat count is larger than 1, emit when animation play to the last frame
        - finished : Emit when finish playing animation

        !#zh Animation 组件用于播放动画。

        Animation 提供了一系列可注册的事件：
        - play : 开始播放时
        - stop : 停止播放时
        - pause : 暂停播放时
        - resume : 恢复播放时
        - lastframe : 假如动画循环次数大于 1，当动画播放到最后一帧时
        - finished : 动画播放完成时 */
        animation: cc.Animation;
        /**!#en Audio Source. !#zh 音频源组件，能对音频剪辑。 */
        audio_source: cc.AudioSource;
        /**!#en Camera is usefull when making reel game or other games which need scroll screen. Using camera will be more efficient than moving node to scroll screen. Camera !#zh 摄像机在制作卷轴或是其他需要移动屏幕的游戏时比较有用，使用摄像机将会比移动节点来移动屏幕更加高效。 */
        camera: cc.Camera;
        /**!#en cc.MotionStreak manages a Ribbon based on it's motion in absolute space. You construct it with a fadeTime, minimum segment size, texture path, texture length and color. The fadeTime controls how long it takes each vertex in the streak to fade out, the minimum segment size it how many pixels the streak will move before adding a new ribbon segment, and the texture length is the how many pixels the texture is stretched across. The texture is vertically aligned along the streak segment. !#zh 运动轨迹，用于游戏对象的运动轨迹上实现拖尾渐隐效果。 */
        motion_streak: cc.MotionStreak;
        /**骨骼动画 */
        skeleton_animation: cc.SkeletonAnimation;
        /** !#en SwanSubContextView is a view component which controls open data context viewport in WeChat game platform.<br/>
        The component's node size decide the viewport of the sub context content in main context,
        the entire sub context texture will be scaled to the node's bounding box area.<br/>
        This component provides multiple important features:<br/>
        1. Sub context could use its own resolution size and policy.<br/>
        2. Sub context could be minized to smallest size it needed.<br/>
        3. Resolution of sub context content could be increased.<br/>
        4. User touch input is transformed to the correct viewport.<br/>
        5. Texture update is handled by this component. User don't need to worry.<br/>
        One important thing to be noted, whenever the node's bounding box change,
        you need to manually reset the viewport of sub context using updateSubContextViewport.
        !#zh SwanSubContextView 可以用来控制百度小游戏平台开放数据域在主域中的视窗的位置。<br/>
        这个组件的节点尺寸决定了开放数据域内容在主域中的尺寸，整个开放数据域会被缩放到节点的包围盒范围内。<br/>
        在这个组件的控制下，用户可以更自由得控制开放数据域：<br/>
        1. 子域中可以使用独立的设计分辨率和适配模式<br/>
        2. 子域区域尺寸可以缩小到只容纳内容即可<br/>
        3. 子域的分辨率也可以被放大，以便获得更清晰的显示效果<br/>
        4. 用户输入坐标会被自动转换到正确的子域视窗中<br/>
        5. 子域内容贴图的更新由组件负责，用户不需要处理<br/>
        唯一需要注意的是，当子域节点的包围盒发生改变时，开发者需要使用 `updateSubContextViewport` 来手动更新子域视窗。 */
        swan_sub_context_view: cc.SwanSubContextView;
        /** !#en WXSubContextView is a view component which controls open data context viewport in WeChat game platform.<br/>
        The component's node size decide the viewport of the sub context content in main context,
        the entire sub context texture will be scaled to the node's bounding box area.<br/>
        This component provides multiple important features:<br/>
        1. Sub context could use its own resolution size and policy.<br/>
        2. Sub context could be minized to smallest size it needed.<br/>
        3. Resolution of sub context content could be increased.<br/>
        4. User touch input is transformed to the correct viewport.<br/>
        5. Texture update is handled by this component. User don't need to worry.<br/>
        One important thing to be noted, whenever the node's bounding box change,
        you need to manually reset the viewport of sub context using updateSubContextViewport.
        !#zh WXSubContextView 可以用来控制微信小游戏平台开放数据域在主域中的视窗的位置。<br/>
        这个组件的节点尺寸决定了开放数据域内容在主域中的尺寸，整个开放数据域会被缩放到节点的包围盒范围内。<br/>
        在这个组件的控制下，用户可以更自由得控制开放数据域：<br/>
        1. 子域中可以使用独立的设计分辨率和适配模式<br/>
        2. 子域区域尺寸可以缩小到只容纳内容即可<br/>
        3. 子域的分辨率也可以被放大，以便获得更清晰的显示效果<br/>
        4. 用户输入坐标会被自动转换到正确的子域视窗中<br/>
        5. 子域内容贴图的更新由组件负责，用户不需要处理<br/>
        唯一需要注意的是，当子域节点的包围盒发生改变时，开发者需要使用 `updateSubContextViewport` 来手动更新子域视窗。 */
        wx_sub_context_view: cc.WXSubContextView;
    }
}